# [LeetCode] 12. Integer to Roman (Medium)

- **Link:** [LeetCode Problem Link](https://leetcode.com/problems/integer-to-roman/description/?envType=study-plan-v2&envId=top-interview-150)
- **Tags:** `Hash Table`, `Math`, `String`
- **Difficulty:** Medium

## 題目解釋
給定一個整數 `num`，將其轉換為羅馬數字。
羅馬數字由千位、百位、十位、個位依次轉換。關鍵在於處理「減法規則」：當出現 4 或 9 時，需使用特定的雙字母組合（如 4 是 `IV`，9 是 `IX`）。

## 解法思路

### 思考過程：
這是一個經典的 **Greedy（貪婪演算法）** 問題。我們希望每次都盡可能使用「目前能選的最大面值」來扣除剩餘的數值。

為了讓邏輯更簡潔，我們將 4, 9, 40, 90, 400, 900 這六個特殊組合也視為獨立的「面值」存入對照表中。這樣我們就不需要寫複雜的 `if-else` 來判斷何時該用減法，只需由大到小遍歷對照表即可。

### 解法：Greedy 貪婪湊數法
> [!IMPORTANT]
> **思路：**
> 1. 建立對照表（使用 `struct` 或 `pair`），包含所有標準符號與減法組合，按**數值由大到小**排列。
> 2. 由大到小遍歷對照表，若 `num` 大於等於當前面值，就重複扣除並在字串末尾加上符號。
> 3. 當 `num` 歸零時，轉換完成。

### 複雜度分析

| 項目 | 複雜度 | 解釋 |
| :--- | :--- | :--- |
| **時間** | **$O(N)$** | **線性時間**。在通則下，運算次數與 $num$ 的大小成正比。雖然符號面值很大（如 1000），但本質上是透過重複減法來構建字串，其複雜度取決於輸出的羅馬數字長度。 |
| **空間** | **$O(1)$** | **常數空間**。對照表大小固定（13 個元素），不隨 `num` 增大而改變。 |

```cpp
class Solution {
private:
    struct RomanMapping {
        int value;
        string roman;
    };

    // 包含 6 個特殊減法規則的對照表
    const vector<RomanMapping> romanMap = {
        {1000, "M"}, {900, "CM"}, {500, "D"}, {400, "CD"},
        {100, "C"}, {90, "XC"}, {50, "L"}, {40, "XL"},
        {10, "X"}, {9, "IX"}, {5, "V"}, {4, "IV"},
        {1, "I"}
    };

public:
    string intToRoman(int num) {
        string ans = "";
        
        for(const auto& p : romanMap) {
            // 只要當前數字還夠扣，就持續使用該羅馬符號
            while(num >= p.value) {
                num -= p.value;
                ans += p.roman;
            }
            if(num == 0) break;
        }
        
        return ans;
    }
};
```
