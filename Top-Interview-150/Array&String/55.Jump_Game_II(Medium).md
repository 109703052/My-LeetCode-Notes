# [LeetCode] 45. Jump Game II(Medium)

- **Link:** [LeetCode Problem Link](https://leetcode.com/problems/jump-game-ii/description/?envType=study-plan-v2&envId=top-interview-150)
- **Tags:** `Array`, `Dynamic Programming`,`Greedy`
- **Difficulty:** Medium
## 題目解釋
[[LeetCode] 55. Jump Game(Medium)](https://leetcode.com/problems/jump-game/?envType=study-plan-v2&envId=top-interview-150) 的變化題

會得到一個int陣列 `nums` ，裡面的值代表在這個位置能跳的最大距離， `nums[i]`的值假設為 `k` 代表從第 `i` 格最多能跳k格，可以從第 `i` 格跳到第 `i + k` 格，或者是這區間的任一格。

起始位置在第一個index，題目測資保證必定能跳到最後一個index，要return最少需要jump幾次可以達到最後一個index。

## 解法思路

### 解法一：Greedy
> [!IMPORTANT]
> **思路：**
> 每次跳躍的時候站在當前位置，去掃描所有能跳到的點，選擇那個『能讓我下一跳去得最遠』的點當作落腳點。
> 
- **時間複雜度:** $O(n*k)$ - (k為最大跳躍距離)
- **空間複雜度:** $O(1)$ - 只用到常數個變數

缺點:有些區間會被重複檢查
```cpp
class Solution {
public:
    int jump(vector<int>& nums) {
        int n = nums.size();
        if(n == 1){
            return 0;
        }
        int min_jump = 0;
        int can_reach = 0;
        int i = 0;
        while(i < n - 1){
            int now_can_reach = i + nums[i];
            if(now_can_reach >= n - 1){
                return min_jump + 1;
            }
            int this_step_to_reach = 0;
            int j = i;
            while(j <= now_can_reach){
                if(j + nums[j] >= can_reach){
                    can_reach = j + nums[j];
                    this_step_to_reach = j;
                }
                j++;
            }
            i = this_step_to_reach;
            min_jump++;
            if(i >= n - 1){
                break;
            }
        }
        return min_jump;
    }
};
```
### 解法二：Greedy(最佳解)
> [!IMPORTANT]
> **思路：**
> 每次跳躍的時候，不去想這一步要跳到哪裡，而是思考這一步最遠能覆蓋到哪。
> 把每一次跳躍想像成能到達範圍區間的推進，透過每次跳躍一層一層推進
> - 第一步:能到達的範圍區間是 `[0, nums[0]]`
> - 第二步: `[0, nums[0]]` 區間內任意點再跳一次的最遠距離
> 以此類推
### 1. 核心變數定義
我們維護兩個關鍵指標：

- **`current_edge` (當前邊界)** 目前的跳躍次數下，我們最遠能到達的右邊界。這就像是一道「牆」，在撞到這道牆之前，我們都在「同一跳」的範圍內移動。

- **`next_edge` (下一跳的最遠潛力)** 在掃描當前範圍的過程中，計算如果從當前位置再跳一步，最遠能延伸到哪裡。

### 2. 演算法流程 (單次掃描)
我們只需要遍歷陣列一次 ($O(N)$)：

1. **不斷更新潛力 (`next_edge`)** 每走到一個索引 `i`，我們都檢查 `i + nums[i]`，看看能不能刷新 `next_edge`。這代表「如果我決定從這裡跳，我能去得更遠嗎？」

2. **撞牆判定 (`i == current_edge`)** 當我們走到了 `current_edge`，代表「上一步所能覆蓋的範圍」已經走完了。
   - 這時我們**必須**進行下一次跳躍（`jumps++`）。
   - 我們將邊界推進到剛才計算出的最遠潛力位置（`current_edge = next_edge`）。

### 3. 終止條件
- 迴圈只需要走到 `n-2`。
- 因為題目保證能到達終點，如果我們已經站在 `n-1` 上，就不需要再計算是否要起跳了。

### 複雜度
- **時間複雜度:** $O(n*k)$ - (k為最大跳躍距離)
- **空間複雜度:** $O(1)$ - 只用到常數個變數


```cpp
class Solution {
public:
    int jump(vector<int>& nums) {
        int n = nums.size();
        if(n == 1) return 0;
        
        int current_edge = nums[0];
        int next_edge = nums[0];
        int jumps = 1;
        
        for(int i = 0; i < n - 1; i++){
            // 1. 不斷更新潛力
            next_edge = max(i + nums[i], next_edge);

            // 2. 撞牆判定
            if(i == current_edge){
                current_edge = next_edge;
                jumps++;
            }
        }
        return jumps;
    }
};
