# [LeetCode] 189. Rotate Array (Medium)

- **Link:** [LeetCode Problem Link](https://leetcode.com/problems/rotate-array/description/?envType=study-plan-v2&envId=top-interview-150)
- **Tags:** `Array`, `Math`, `Two Pointers`
- **Difficulty:** Medium

## 題目解釋

給定一個整數 Array `nums`，將陣列中的元素向右輪轉 (Rotate) `k` 個位置，其中 `k` 是非負整數。

**Follow up:**
1. 至少有三種不同的解法。
2. 能否使用 **In-place** (原地演算法) 且僅使用 **$O(1)$** 的額外空間來解決？

> [!WARNING]
> **關鍵陷阱 (Edge Case):**
> 注意 `k` 可能大於陣列長度 `n`。
> 例如 `n = 5`, `k = 7`，其實等於轉 `2` 次。
> **前處理：** 務必執行 `k = k % nums.size();`

---

## 解法思路

### 解法一：開新的大小為`n`的vector方便複製
最直覺的方法，開一個新的 `vector`，計算好新位置後填入。
> [!IMPORTANT]**思路：**
> 最直覺的方法，開一個新的 `vector`，計算好新位置後填入。
- **時間複雜度:** $O(n)$
- **空間複雜度:** $O(k)$ - 比解法一省空間，但仍不是 O(1)

- **時間複雜度:** $O(n)$
- **空間複雜度:** $O(n)$ - *不符合 Follow up 要求*

```cpp
class Solution {
public:
    void rotate(vector<int>& nums, int k) {
        int n = nums.size();
        k = k % n; // 若 k 超過陣列長度，取餘數避免多餘運算 (例如 k=7, n=5 等同於 k=2)     
        vector<int> temp(n);
        for(int i = 0; i < n; i++) {
            temp[(i + k) % n] = nums[i];
        }
        nums = temp;
    }
};
```

### 解法二:開新的大小為`k`的vector方便複製


> [!IMPORTANT]
> **思路：**
> 1. 不需要複製整個陣列，先建立一個大小為 `k` 的 vector 當作暫存區，備份陣列**最後 k 個**元素 (因為它們在步驟2會被覆蓋)。
> 2. **核心步驟：** 從索引 `n - k - 1` (即倒數第 `k+1` 個元素) 開始 **「由後往前」** 遍歷至 `0`，將每個元素往右平移 `k` 格 (`nums[i+k] = nums[i]`)。
> 3. 最後將暫存區的元素填回陣列最前面的 `k` 個位置。
- **時間複雜度:** $O(n)$
- **空間複雜度:** $O(k)$ - 比解法一省空間，但仍不是 O(1)

```cpp
class Solution {
public:
    void rotate(vector<int>& nums, int k) {
        k = k%(nums.size());
        vector<int> tmp(nums.end() - k, nums.end());
        //vector<T> 新名稱(起始位置, 結束位置);
        //從 "nums" 陣列中，複製最後 k 個元素，用來初始化新的 "tmp" 陣列。
        
        for(int i=nums.size() - 1;i >= k;i--){
            nums[i] = nums[i-k];
        }
        for(int i=0;i < k;i++){
            nums[i] = tmp[i];
        }
    }
};
```

### 解法三:

> [!IMPORTANT]
> **思路：**
> 以 `[1,2,3,4,5,6,7]` 為例
> 1. 先把整個陣列順序顛倒變成 `[7,6,5,4,3,2,1]`
> 2. 再把前`k`個數字順序顛倒，這邊假設`k=3` ，所以變成`[5,6,7,4,3,2,1]`
> 3. 最後再把剩下後面的n-k個數字順序顛倒回來，變成`[5,6,7,1,2,3,4]`
- **時間複雜度:** $O(n)$
- **空間複雜度:** $O(1)$ - 只需要一個tmp來當作swap的暫存

reverse(順序顛倒)做法:用兩個指針把想要替換區間的`第一個`和`倒數第一個`進行swap，`第二個`跟`倒數第二個`swap，以此類推，所以只需要一個tmp來當作swap的暫存

```cpp
class Solution {
public:
    void my_reverse(vector<int>& nums,int left, int right){
        //[L,R] 左閉右閉
        int tmp;
        while(left < right){
            tmp = nums[left];
            nums[left] = nums[right];
            nums[right] = tmp;
            left++;
            right--;
        }
    }
    void rotate(vector<int>& nums, int k) {
        int n = nums.size();
        k = k % n;

        my_reverse(nums, 0, n-1);
        my_reverse(nums, 0, k-1);
        my_reverse(nums, k, n-1);
    }
};
```

> [!TIP]
> C++ STL 小撇步 
如果允許使用標準函式庫，可以使用 <algorithm> 中的 reverse 來簡化程式碼。 注意 STL 的區間通常是 [左閉右開)：
```cpp
class Solution {
public:
    void rotate(vector<int>& nums, int k) {
        int n = nums.size();
        k = k % n;
        
        // reverse 定義在 <algorithm> 中
        reverse(nums.begin(), nums.end());
        reverse(nums.begin(), nums.begin() + k);
        reverse(nums.begin() + k, nums.end());
    }
};
```
