# [LeetCode] 135. Candy(Hard)

- **Link:** [LeetCode Problem Link](https://leetcode.com/problems/candy/description/?envType=study-plan-v2&envId=top-interview-150)
- **Tags:** `Array`, `Greedy`
- **Difficulty:** Hard

## 題目解釋
發糖果給一排同學，每人最少發一顆，每個人會有評分 `ratings[i]` ，如果有人評分比左邊鄰居高，那他拿到的糖果會比左邊鄰居多，如果評分比右邊鄰居高，那他會拿到比右邊鄰居多的糖果。

## 解法思路

### 思考過程:
這題題目是求最小總和，並且一個人拿到的糖果限制只來自於左右鄰居，這時可以用Greedy的角度去思考，利用局部最優解導向全局最優解。
因為這題要同時考慮左右鄰居的條件有點困難，將 **同時與左右鄰居比較** 這個困難的問題，拆解成 **只跟左邊比** 和 **只跟右邊比** 兩個簡單的問題來解決。


### 解法：「兩次遍歷貪婪法」（Two-Pass Greedy）。
> [!IMPORTANT]
> **思路：**
> 1. 題目規定每個人至少一顆糖果，所以先初始化假設每個人都只有一顆糖果。
> 2. 由左至右掃描，在每一個點確認 **我是否贏過左邊的鄰居** 如果是，那我的糖果必須比左邊鄰居多一顆。
> 3. 由右至左掃描，在每一個點確認 **我是否贏過右邊的鄰居** 如果是，那我的糖果必須比右邊鄰居多一顆以上。
> (如果原本就比右邊多的話就保持不動，避免破壞前面建立好的比左鄰居多的原則。如果原本比右邊少，則此時糖果只需比右邊多一顆即可。)


### 複雜度分析

| 項目 | 複雜度 | 解釋 |
| :--- | :--- | :--- |
| **時間** | **$O(N)$** | **線性時間**。程式碼中雖然有多次迴圈（一次左掃描、一次右掃描、一次加總），但它們是並列的而非巢狀（Nested），總運算次數約為 $3N$，省略常數後為 $O(N)$。 |
| **空間** | **$O(N)$** | **線性空間**。我們建立了一個大小為 $N$ 的陣列 has 來儲存每個孩子的糖果數，記憶體消耗會隨著人數 $N$ 線性增加。 |

```cpp
class Solution {
public:
    int candy(vector<int>& ratings) {
        int n = ratings.size();
        vector<int> has(n, 1);
        for(int i=1;i < n;i++){
            if(ratings[i] > ratings[i-1]){
                has[i] = has[i-1] + 1;
            }
        }
        for(int i=n-2;i >=0;i--){
            if(ratings[i] > ratings[i+1] && has[i] <= has[i+1]){
                has[i] = has[i+1] + 1;
            }
        }
        int sum = 0;
        for(int num:has){
            sum += num;
        }
        return sum;
    }
};
```
