# [LeetCode] 13. Roman to Integer (Easy)

- **Link:** [LeetCode Problem Link](https://leetcode.com/problems/roman-to-integer/description/?envType=study-plan-v2&envId=top-interview-150)
- **Tags:** `Hash Table`, `Math`, `String`
- **Difficulty:** Easy

## 題目解釋
將羅馬數字字串轉換為整數。羅馬數字包含七種符號：`I(1)`, `V(5)`, `X(10)`, `L(50)`, `C(100)`, `D(500)`, `M(1000)`。

**規則：**
1. 通常由大到小排列（左至右），直接相加。
2. **特殊減法規則**：若小符號在大符號左邊，則代表減法。
   - `I` 放在 `V` 或 `X` 前：4, 9
   - `X` 放在 `L` 或 `C` 前：40, 90
   - `C` 放在 `D` 或 `M` 前：400, 900

## 解法思路

### 思考過程：
觀察羅馬數字，判定加減法的關鍵在於**當前字元**與**下一個字元**的數值關係：
* 如果 **當前值 $\ge$ 右邊值**：代表這是正常的累加（例如 `VI` = $5 + 1$）。
* 如果 **當前值 $<$ 右邊值**：代表這是減法組合（例如 `IV` = $-1 + 5$）。

我們可以使用 `unordered_map` 來儲存對應關係，並透過一次線性歷遍（Linear Scan）完成計算。

### 解法：線性掃描判斷 (One Pass)
> [!IMPORTANT]
> **思路：**
> 1. 建立 `unordered_map` 作為查表，存入羅馬符號與數值的對應。
> 2. 歷遍字串，比較當前字元 `s[i]` 與後一個字元 `s[i+1]`。
> 3. 若 `s[i]` 的值較小，總和扣除該值；否則，總和加上該值。
> 4. 最後一個字元因為後方沒有對比對象，必定是累加。

### 複雜度分析

| 項目 | 複雜度 | 解釋 |
| :--- | :--- | :--- |
| **時間** | **$O(N)$** | **線性時間**。只需歷遍字串一次，其中 $N$ 為字串長度。 |
| **空間** | **$O(1)$** | **常數空間**。雜湊表大小固定（7 個字元），不隨輸入規模增加。 |

```cpp
class Solution {
public:
    int romanToInt(string s) {
        unordered_map<char, int> roman_to_int = {
            {'I', 1},
            {'V', 5},
            {'X', 10},
            {'L', 50},
            {'C', 100},
            {'D', 500},
            {'M', 1000}
        };
        
        int val = 0;
        int n = s.size();

        for(int i = 0; i < n; i++){
            // 判斷當前數值是否小於右側數值 (需先檢查邊界避免越界)
            if(i < n - 1 && roman_to_int[s[i]] < roman_to_int[s[i+1]]){
                val -= roman_to_int[s[i]];
            }
            else{
                val += roman_to_int[s[i]];
            }
        }

        return val;
    }
};
```
