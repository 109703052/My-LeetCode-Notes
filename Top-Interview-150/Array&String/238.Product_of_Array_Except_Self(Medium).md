# [LeetCode] 238. Product of Array Except Self(Medium)

- **Link:** [LeetCode Problem Link](https://leetcode.com/problems/product-of-array-except-self/description/?envType=study-plan-v2&envId=top-interview-150)
- **Tags:** `Array`, `Prefix Sum`
- **Difficulty:** Medium

## 題目解釋
給定一個陣列 `nums` ，回傳一個陣列 `ans` ，其中 `ans[i]` 的值為 `nums` 中除了 `nums[i]` 以外所有元素的乘積。


**限制與條件**

* 使用演算法的時間複雜度需為 $O(n)$ ，並且過程中不能使用到除法
* 任何前綴積或是後綴積一定是 **32bit int** 可以放得下的數字(算是一種提示)

**Follow up**
* 僅使用 $O(1)$ 的額外空間( `ans` 不算在額外空間內)
## 解法思路

### 思考過程:
一開始最直觀想到的方法把所有數字都相乘出來記為 `x`，則 `ans[i]` 的值就是 `x / nums[i]` ，但是題目提到不能使用除法，而且這個方法會有個問題: 當 `nums[i] == 0` 時會造成 **Exception** ，所以即使題目允許使用除法也可能會有問題或是很多例外狀況要處理。

因為題目中有提到任何前綴積或是後綴積一定是 **32bit int** 可以放得下的數字，所以可以運用這一點下去思考，把 `ans[i]` 看成 `nums[0] * nums[1] * ... * nums[i-1]` 乘上 `nums[i+1] * nums[i+2] * ... * nums[n-1]` (其中n為 `nums` 的size)

所以這時候只需要花費 $O(n)$ 的時間去計算出各位置的前綴積和後綴積就可以得出答案了。

### 解法：算出前綴積和後綴積再求出結果
> [!IMPORTANT]
> **思路：**
> 我們把 $ans[i]$ 拆解為兩個部分的乘積：
> 1. 左半部（Prefix）：`nums[0]` 到 `nums[i-1]` 的乘積。
> 2. 右半部（Suffix）：`nums[i+1]` 到 `nums[n-1]` 的乘積。
> 
> $ans[i] = \text{Prefix}[i] \times \text{Suffix}[i]$

### 複雜度分析 (解法一：前綴與後綴陣列)

| 維度 | 複雜度 | 說明 |
| :--- | :--- | :--- |
| **時間複雜度** | $O(n)$ | 進行了兩次線性掃描。第一次掃描同步計算前綴與後綴積，第二次掃描結合兩者得出結果。 |
| **空間複雜度** | $O(n)$ | 額外使用了 `prefix_product` 與 `suffix_product` 兩個大小為 $n$ 的陣列來儲存中間計算結果。 |


```cpp
class Solution {
public:
    vector<int> productExceptSelf(vector<int>& nums) {
        int n = nums.size();
        // 初始化三個向量，空間複雜度為 O(n)
        vector<int> prefix_product(n, 1);
        vector<int> suffix_product(n, 1);
        vector<int> ans(n, 1);

        prefix_product[0] = nums[0];
        suffix_product[n-1] = nums[n-1];

        // 計算前綴積與後綴積
        for(int i = 1; i < n; i++){
            prefix_product[i] = prefix_product[i-1] * nums[i];
            suffix_product[n-1-i] = suffix_product[n-i] * nums[n-1-i];
        }

        // 處理邊界：第一個數的結果是右邊所有人的積，最後一個數是左邊所有人的積
        ans[0] = suffix_product[1];
        ans[n-1] = prefix_product[n-2];

        // 處理中間：ans[i] = 左積[i-1] * 右積[i+1]
        for(int i = 1; i < n - 1; i++){
            ans[i] = prefix_product[i-1] * suffix_product[i+1];
        }

        return ans;
    }
};
```

### 解法二：空間優化版 (Single Array + Prefix Variable)

> [!TIP]
> **優化思路：**
> 我們不再開立 `prefix_product` 和 `suffix_product` 兩個陣列，而是直接利用 `ans` 陣列來儲存其中一側的積（此處先存後綴積），再用一個常數變數 `prefix_product` 在第二次遍歷時動態維護另一側的積，並直接與 `ans` 中的數值相乘。

#### 程式碼實作

```cpp
class Solution {
public:
    vector<int> productExceptSelf(vector<int>& nums) {
        int n = nums.size();
        // 初始化 ans 陣列，這不計入額外空間複雜度
        vector<int> ans(n, 1);

        // 第一步：由右向左計算「後綴積」並存入 ans
        // ans[i] 代表 i 右邊所有元素的乘積
        for(int i = n - 2; i >= 0; i--){
            ans[i] = ans[i + 1] * nums[i + 1];
        }

        // 第二步：由左向右計算「前綴積」並直接乘入 ans
        int prefix_product = 1;
        for(int i = 0; i < n; i++){
            ans[i] *= prefix_product;   // 目前的 ans[i] (右積) * 當前的 prefix_product (左積)
            prefix_product *= nums[i];  // 更新左積，供下一個 index 使用
        }

        return ans;
    }
};
```
### 複雜度分析

| 維度 | 複雜度 | 說明 |
| :--- | :--- | :--- |
| **時間複雜度** | $O(n)$ | 進行了兩次線性掃描，第一次由右向左，第二次由左向右。 |
| **空間複雜度** | $O(1)$ | 除了回傳結果用的 `ans` 向量外，僅使用了一個 `int` 變數 `prefix_product`，因此額外空間為常數級別。 |
