# [LeetCode] 42. Trapping Rain Water(Hard)


- **Link:** [LeetCode Problem Link](https://leetcode.com/problems/trapping-rain-water/description/?envType=study-plan-v2&envId=top-interview-150)
- **Tags:** `Array`, `Two Pointers`, `Dynamic Programming`, `Stack`, `Monotonic Stack`
- **Difficulty:** Hard

## 題目解釋
你會得到一個代表地勢高低的陣列 `height` ，計算出這些空間可以接多少雨水。

## 解法思路

### 思考過程:
要儲存雨水，代表要形成低漥地形才能儲存雨水，不然水會流走。
所以儲存水量的關鍵在於左右兩高點之間的空間，在任何一個位置，水能淹多高取決於 **左邊最高的山** 以及 **右邊最高的山** ，而這兩座山當中 **較矮者** 就是中間的極限水位。

但是如果只是從左至右歷遍陣列找每一個水坑的左右邊高度，會需要 $O(n^2)$ 的時間複雜度。
如果想要達到 $O(n)$ 的時間複雜度，就需要用Greedy的方法來避免重複計算，同時比較最左邊和最右邊的高度，因為 **水坑高度一定被水位較低的那一邊所限制** ，所以當左(右)邊的高度已經確定較低時，左(右)邊的水位高度已經可以結算。


### 解法：雙指針的Greedy
> [!IMPORTANT]
> **思路：**
> 1. 同時維護左右兩個指針，用於比較左右當前位置的高度。
> 2. 比較左右當前高度，若是左邊較高，右邊指針水位為 `右指針當前遇過最高高度` ，則這一格儲存到的水量為 `right_max_height - height[right]`
> 3. 反之亦然。

### 複雜度分析

| 項目 | 複雜度 | 解釋 |
| :--- | :--- | :--- |
| **時間** | **$O(N)$** | **線性時間**。我們使用雙指標（`left` 和 `right`）從陣列兩端往中間移動，直到相遇。每個元素只會被存取並處理一次，總運算次數與陣列長度 $N$ 成正比。 |
| **空間** | **$O(1)$** | **常數空間**。僅使用了有限的幾個整數變數（`left`, `right`, `left_max`, `right_max`, `sum`）來記錄當下的極值與總和，記憶體消耗不隨 $N$ 增加。 |

```cpp
class Solution {
public:
    int trap(vector<int>& height) {
        int n = height.size();
        int left = 0;
        int left_max_height = height[0];
        int right = n - 1;
        int right_max_height = height[n-1];
        int sum = 0;
        while(left < right){
            if(height[left] <= height[right]){
                left_max_height = max(left_max_height, height[left]);

                sum += left_max_height - height[left];
                left++;
            }
            else{
                right_max_height = max(right_max_height, height[right]);

                sum += right_max_height - height[right];
                right--;
            }
        }
        

        return sum;
    }
};
```
