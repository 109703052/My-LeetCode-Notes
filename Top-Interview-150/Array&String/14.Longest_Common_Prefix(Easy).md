# [LeetCode] 14. Longest Common Prefix (Easy)

- **Link:** [LeetCode Problem Link](https://leetcode.com/problems/longest-common-prefix/description/?envType=study-plan-v2&envId=top-interview-150)
- **Tags:** `String`, `Trie`, `Sorting`
- **Difficulty:** Easy

## 題目解釋
編寫一個函式來查找字串陣列中的最長共同前綴。如果不存在共同前綴，則返回空字串 `""`。

---





### 解法一：縱向掃描 (Vertical Scanning)
> [!IMPORTANT]
> **思路：**
> 1. 直接把第一個字串(或者任意字串)拿來和所有其他字串比對
> 2. 如果第一個字元和所有字串的第一個字元比對成功，把這個字元加入答案中，以此類推執行每一個字元。
> 3. 如果字元不符或者是長度不符，直接輸出答案

### 複雜度分析
| 項目 | 複雜度 | 解釋 |
| :--- | :--- | :--- |
| **時間** | **$O(S)$** | $S$ 是所有字串中字元數的總和。最壞情況下會檢查所有字元。 |
| **空間** | **$O(1)$** | 僅使用常數空間來儲存索引與結果（結果字串不計入空間複雜度）。 |

```cpp
class Solution {
public:
    string longestCommonPrefix(vector<string>& strs) {
        if(strs.empty()) return "";
        
        string ans = "";
        string s0 = strs[0]; // 以第一個字串為基準
        
        for(int i = 0; i < s0.size(); i++) {
            char c = s0[i];
            for(int j = 1; j < strs.size(); j++) {
                // 如果索引超過字串長度，或字元不符合，立即回傳
                if(i == strs[j].size() || c != strs[j][i]) {
                    return ans;
                }
            }
            ans += c;
        }
        return ans;
    }
};
```


### 解法二：排序 (Sorting)
> [!IMPORTANT]
> **思路：**
> 1. 對字串進行排序，排序完之後第一個字串和最後一個字串的字元差距一定是最大的
> 2. 所以這時只要取第一個字串和最後一個字串進行每個字元比對，如果字元相同，那麼中間n-2個字串一定也相同(因為排序過了)，則可以把字元加入答案。
> 3. 若是出現不同字元或是長度不同，則直接輸出答案

### 複雜度分析

| 項目 | 複雜度 | 解釋 |
| :--- | :--- | :--- |
| **時間** | $O(N \cdot L \log N)$ | $N$ 是字串個數，$L$ 是平均長度。主要開銷在於排序，排序字串需考慮長度。 |
| **空間** | $O(1)$ | 若不計排序所需的系統堆疊空間，則為常數空間。 |



```cpp
class Solution {
public:
    string longestCommonPrefix(vector<string>& strs) {
        string ans = "";
        sort(strs.begin(), strs.end());
        int n = strs.size();
        for(int i=0;i < strs[0].size();i++){
            if(i == strs[n-1].size()){
                return ans;
            }
            if(strs[0][i] == strs[n-1][i]){
                ans += strs[0][i];
            }
            else{
                return ans;
            }
        }
        return ans;
    }
};
```

---

## 解法比較與討論

| 比較項目 | 解法一：縱向掃描 | 解法二：排序法 |
| :--- | :--- | :--- |
| **最佳場景** | **大多數通用場景**。特別是當共同前綴很短時，能極快結束。 | **程式碼簡潔度高**。適用於需要對字串陣列進行後續排序操作的場景。 |
| **效能表現** | **較穩定**。時間複雜度 $O(S)$ 是此問題的理論下界。 | **較慢**。排序的開銷 $O(N \cdot L \log N)$ 通常大於單純掃描。 |
| **邏輯核心** | 逐位檢查，一旦不符即停（Early Exit）。 | 利用「字典序」特性，只比較差異最大的兩端。 |

### 為什麼面試官喜歡討論這兩者？
1. **縱向掃描（Vertical Scanning）** 展現了你對**最優時間複雜度**的追求。在最壞情況下，每個字元只會被讀取一次，沒有多餘的預處理。
2. **排序法（Sorting）** 展現了你的**側向思考能力**。這是一種將複雜問題簡化（Reduction）的技巧：透過排序將「多個字串的比較」簡化為「兩個極端值的比較」。

> [!TIP]
> **面試建議：** > 如果面試官問「如何進一步優化」，可以提到如果字串數量極大且經常需要查詢，可以使用 **Trie (字典樹)** 結構來儲存，這樣查詢共同前綴的時間複雜度會降至 $O(L)$。
