# [LeetCode] 58. Length of Last Word (Easy)

- **Link:** [LeetCode Problem Link](https://leetcode.com/problems/length-of-last-word/description/?envType=study-plan-v2&envId=top-interview-150)
- **Tags:** `String`
- **Difficulty:** Easy

## 題目解釋
給定一個字串 `s`，由單字和空格組成，回傳其中 **最後一個** 單字的長度。
單字的定義是：不含空格的連續字元子字串。

## 解法思路

### 思考過程：
這題最直接的直覺是從字串的**末尾**開始往前掃描：
1. **忽略末尾空格**：字串最後面可能有連續的空格（例如 `"moon  "`），這些不屬於單字。
2. **計算單字長度**：一旦遇到第一個非空格字元，就開始累加長度，直到再次遇到空格或碰到字串開頭為止。

這種「反向掃描」法不需要像正向遍歷那樣處理每一個單字並不斷重置長度，效率更高且邏輯直觀。

### 解法：反向線性掃描 (Reverse Linear Scan)
> [!IMPORTANT]
> **思路：**
> 1. 從字串最後一個索引 `n-1` 開始往前遍歷。
> 2. **條件一：** 如果遇到非空格字元，`length++`。
> 3. **條件二：** 如果遇到空格，且此時 `length > 0`，代表我們剛才已經數完最後一個單字了，直接回傳 `length`。
> 4. 若遍歷結束（到達字串開頭）仍未觸發回傳，則回傳目前的 `length`。

### 複雜度分析

| 項目 | 複雜度 | 解釋 |
| :--- | :--- | :--- |
| **時間** | **$O(N)$** | **線性時間**。最差情況下（例如只有一個單字且在開頭）需遍歷整個字串，但平均而言只需掃描字串末尾部分。 |
| **空間** | **$O(1)$** | **常數空間**。僅使用了一個整數變數 `length`。 |

```cpp
class Solution {
public:
    int lengthOfLastWord(string s) {
        int length = 0;
        for(int i=s.size()-1;i >=0;i--){
            if(s[i] == ' ' && length != 0){
                return length;
            }
            else if(s[i] != ' '){
                length++;
            }
        }
        return length;
    }
};
```
