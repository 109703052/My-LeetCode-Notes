# [LeetCode] 274. H-Index(Medium)

- **Link:** [LeetCode Problem Link](https://leetcode.com/problems/h-index/description/?envType=study-plan-v2&envId=top-interview-150)
- **Tags:** `Array`, `Sorting`, `Counting Sort`, `Bucket Sort`
- **Difficulty:** Medium

## 題目解釋
給定一個整數陣列 `citations`，其中 `citations[i]` 代表研究者的第 `i` 篇論文被引用的次數。要求算出這位研究者的 **H-Index**。

**H-Index 定義：**
一位研究者的 H 指數為 `h`，代表他至少有 `h` 篇論文，每一篇都至少被引用了 `h` 次。如果有多個可能的 `h`，要回傳**最大**的那一個。

## 解法思路

### 解法一：Counting Sort / Bucket Sort (最佳解)
> [!IMPORTANT]
> **思路：**
> 觀察題目限制 `citations[i] <= 1000` (或 N <= 5000)，利用空間換取時間。
> 1. **分桶計數**：開一個大小為 1001 的陣列 `count`，`count[i]` 紀錄引用次數**剛好**為 `i` 的論文有幾篇。
> 2. **後綴和 (Suffix Sum)**：從大到小遍歷，將引用次數較高的論文數量累加到較低的桶子。這樣 `count[i]` 就變成了「引用次數**至少**為 `i` 的論文數量」。
> 3. **尋找 H**：由大到小檢查，找到第一個滿足 `count[i] >= i` 的 `i` 即為答案。

- **時間複雜度:** $O(n)$ - 只需要遍歷陣列與桶子
- **空間複雜度:** $O(n)$ - (或視為 $O(1)$，因為桶子大小固定為 1001)

優點：比排序法更快，特別是當 N 很大但數值範圍有限時。

```cpp
class Solution {
public:
    int hIndex(vector<int>& citations) {
        // 1. 初始化桶子 (必須歸零)
        int count[1001] = {0};
        
        // 2. 統計每種引用次數的篇數
        for(int i : citations){
            count[i]++;
        }
        
        // 3. 由大到小遍歷尋找 H-Index
        for(int i = 1000; i >= 0; i--){
            // 累加：將「引用更多次」的論文數量加進來
            // 這樣 count[i] 就變成「至少被引用 i 次」的論文總數
            if(i < 1000){
                count[i] += count[i+1];
            }
            
            // 判斷：如果有 count[i] 篇論文至少被引用 i 次，且 i 是由大找下來的
            // 則 i 就是最大的 H-Index
            if(count[i] >= i){
                return i;
            }
        }
        return -1;
    }
};
```

### 解法二：Sorting
> [!IMPORTANT]
> **思路：**
> 將論文依照引用次數**由大到小**排序。
> 排序後，index `i` 的論文是第 `i+1` 名。我們只需要檢查這篇論文的引用次數是否撐得起它的排名。
> Ex: 
> 假設排序後為[7,6,5,4,3,2,1]， `citations[3]`排名是第四名，並且他的值為 `4`，代表至少有四篇論文的引用次數大於等於 `4`，此時H-index至少為4。
>  `citations[4]` 的值為 `3` ，他是引用次數第五名的論文，引用次數只有 `3` 次，代表H-Index不可能為 `5`。

> 
> - 如果 `citations[i] >= rank` (rank 為 `i+1`)，代表這前 `rank` 篇論文都合格。
> - 如果 `citations[i] < rank`，代表這篇論文不合格，這時前一篇的排名 (`i`) 就是答案。



- **時間複雜度:** $O(n \log n)$ - 主要花在排序上
- **空間複雜度:** $O(1)$ - (視排序演算法實作而定)

```cpp
class Solution {
public:
    int hIndex(vector<int>& citations) {
        // 1. 由大到小排序 (Descending Sort)
        // 使用 greater<int>() 讓 sort 變成降序
        // 例如: [3, 0, 6, 1, 5] -> [6, 5, 3, 1, 0]
        sort(citations.begin(), citations.end(), greater<int>());
        
        int n = citations.size();
        
        // 2. 依序檢查每一篇論文
        for(int i = 0; i < n; i++) {
            // i 是 index (0, 1, 2...)
            // i + 1 代表目前是「第幾篇」論文 (1, 2, 3...)
            int rank = i + 1;
            
            // 如果這篇論文的引用次數 < 它的排名
            // 代表這篇論文撐不起這個 H 值了，答案就是上一篇的排名 (也就是 i)
            if(citations[i] < rank) {
                return i;
            }
        }
        
        // 3. 特殊情況：如果所有論文都符合 (例如 [100, 99])
        // H-Index 就是論文總數
        return n;
    }
};
