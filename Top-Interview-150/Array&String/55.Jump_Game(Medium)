# [LeetCode] 55. Jump Game(Medium)

- **Link:** [LeetCode Problem Link](https://leetcode.com/problems/jump-game/?envType=study-plan-v2&envId=top-interview-150)
- **Tags:** `Array`, `Dynamic Programming`,`Greedy`
- **Difficulty:** Medium

## 題目解釋

會得到一個int陣列 `nums` ，裡面的值代表在這個位置能跳的最大距離， `nums[i]`的值假設為 `k` 代表從第 `i` 格最多能跳k格，可以從第 `i` 格跳到第 `i + k` 格，或者是這區間的任一格。

你的起始位置在第一個index，如果有辦法成功到達最後一個index就return True，反之則False。

## 解法思路

### 解法一：Greedy
> [!IMPORTANT]
> **思路：**
> 1. 歷遍陣列，用Greedy的方式記錄目前所能到達最遠的position(`max_reach`)
> 2. 如果 `nums[i]` 不全為 `0` 的話，必定可以達到終點
> 3. 如果會出現無法到達最後一格的情況，一定是因為有出現 `nums[i]` 為 `0` 
> 4. 當 `nums[i] == 0` 時，確認 `max_reach` 是否有超過 `i` 
> 5. 若是 `max_reach <= i` 回傳 `False`
> 6. 反之則繼續歷遍陣列，成功到達最後一個index的時候回傳 `True`
> 
- **時間複雜度:** $O(n)$ - 只需歷遍陣列一次
- **空間複雜度:** $O(1)$ - 只用到常數個變數

```cpp=
class Solution {
public:
    bool canJump(vector<int>& nums) {
        int n = nums.size();
        int max_reach = 0;
        int i= 0;
        while(i < n){
            if(max_reach >= n - 1){
                return true;
            }
            else if(nums[i] != 0){
                nums[i] += i;
                max_reach = max(max_reach, nums[i]);
                i++;
            }
            else if(nums[i] == 0){
                if(max_reach <= i){
                    return false;
                }
                i++;
            }
        }
        return true;
    }
};
```

### 解法二：Greedy(優化方法一)
> [!IMPORTANT]
> **思路：**
> 我後來發現可以把方法一的邏輯簡化，不需要特別針對 `nums[i] == 0` 的情況去判斷，只需要在歷遍陣列的同時確認當前index `i` 是否還在我們能到達的範圍內(`max_reach`)即可。
> 如果當前index `i` 超過了 `max_reach` ，則代表後面的index我們已經不可能到達了，直接 `return false` 即可
> 
- **時間複雜度:** $O(n)$ - 只需歷遍陣列一次
- **空間複雜度:** $O(1)$ - 只用到常數個變數

```cpp=
class Solution {
public:
    bool canJump(vector<int>& nums) {
        int n = nums.size();
        int max_reach = 0;
        int i= 0;
        while(i < n){
            if(max_reach < i){
                return false;
            }
            max_reach = max(max_reach, nums[i] + i);
            i++;
        }
        return true;
    }
};
```
